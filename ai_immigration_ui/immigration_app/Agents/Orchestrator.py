import os
from dotenv import load_dotenv
from typing import Dict, Union, Optional, Annotated
from pydantic import BaseModel, Field
from pydantic_ai import Agent, Tool, RunContext
import json
from openai import OpenAI
from pydantic_ai.models.openai import OpenAIModel
from pydantic_ai.providers.openai import OpenAIProvider
import datetime
import logfire
from .AssistantAgent import Assistant_Agent      # relative import inside package
from .NameScraper import Name_Scraper_Agent
from .SiteScraper import Detail_Scraper_Agent
from .Classes import output_agent, ImmigrationProfileModel
from .logging_config import AppLogger

logger = AppLogger().get_logger()

load_dotenv()

class Agent_Output(BaseModel):
    Agent_Name: str = Field(description="The identifier of the agent that produced the response")
    Agent_Output: str = Field(description="The actual content or result generated by the agent")
    Agent_Output_Structure: str = Field(description="The format or schema of the output data")

class Agent_output_evaluation(BaseModel):
    score: float = Field(description="A numerical assessment of the agent's performance, ranging from 0 (poor) to 1 (excellent)")
    feedback: str = Field(description="Constructive feedback to guide future agent interactions or task execution")


class InfoTemplate(BaseModel):

    name: str = Field(description="The name of user")
    age: Union[int, str] = Field(description="The age of user")
    current_country: str = Field(description="The current location of user")
    reason_for_immigration: Union[Dict[str, Union[list, str]], str] = Field(description="The reason for immigration of user")
    target_country: str = Field(description="The target location of user")

    target_job: Union[Dict[str, Union[list, str]], str] = Field(description="if user wants to immigrate for job: The target job of user")
    experience: Union[Dict[str, Union[list, str]], str] = Field(description="User Experiences he has")

    target_education_field: Union[Dict[str, Union[list, str]], str] = Field(description="if user wants to immigrate for Education: The target field of study")
    previous_degrees: Union[Dict[str, Union[list, str]], str] = Field(description="Previous academic degrees and qualifications obtained by the user")
    target_education_degree: Union[Dict[str,str], str] =  Field(description="Target Degree the user want to apply for")
    target_position: Union[Dict[str,str], str] =  Field(description="Target Position the user want to apply for")
    language_proficiency: Union[Dict[str, Union[list, str, float]], str] = Field(description="User IELTS or Toffle or any kind of related test Score")

    financial_status: Union[Dict[str, Union[list, str]], str] = Field(description="Details about the user's financial means to support themselves during the immigration process")

    family_ties: Union[Dict[str, Union[list, str]], str] = Field(default=None, description="Information about family members in the target country, if any")
    
    health_status: Union[Dict[str, Union[list, str]], str] = Field(default=None, description="General health condition and any pertinent medical information")
    
    criminal_record: Union[Dict[str, Union[list, str]], str] = Field(default=None, description="Information regarding any criminal history")

class Name_SearchResult(BaseModel):
    List_of_OverllExtraactednames: list[str] = Field(
        description="The list of all extracted names (company or university)"
    )
    total_results: int = Field(
        description="The total number of results found"
    )
    File_name: str = Field(description="The name of the file to save the extracted names")

class LLM_extracted_list(BaseModel):
    LLM_Extracted_list: list[str] = Field(
        description="The List of searched names Extracted by llm"
    )

    request: str = Field(description="The kind of request done by the agent")
    output: Annotated[str, InfoTemplate, Name_SearchResult, list[str]] = Field(description="The output of the request")

class CommandGen(BaseModel):
    Command: str = Field(description="The command to be executed by the agent")
    Context: Union[str, InfoTemplate, ImmigrationProfileModel] = Field(description="Additional context or information needed to execute the command")


Orchestrator_Agent_Prompt = """
you are a orchestrator agent who will decide which agent to use based on the received command and context, only use allow to use agents and don't reply without using any tool.
"""

Command_evaluation_Prompt = """
you are a control agent who will generate a command base on user input and evaluate the agent output.

Task flow:
1. Receiving input  
   a. If the input comes from the User, parse it into this {CommandGen} format:
      {
         "Command": "<string>",
         "Context": "<string,{ImmigrationProfileModel}>"  # If Context is not specific, use "None"
      }
      **If the user input is a complete profile in the {ImmigrationProfileModel} format, you MUST generate the command "save_new_data" and pass the entire profile object as the Context.**
      - If the input did not mention any specific variable, use "None" as the context.
    
    b. If the input comes from the Orchestrator_Agent, evaluate the agent output:
2. Deciding next action:
    a. if it was a command is generated send it to the Orchestrator_Agent.
    b  if it was a agent output analysis the agent and if the score is above 0.8 return the agent output but if the score is below 0.8 generate a new command and context and send it to the Orchestrator_Agent.

"""
openai_model = OpenAIModel('gpt-4.1', provider=OpenAIProvider(api_key=os.getenv("Main_agents_key")))
Orchestrator_agent = Agent(openai_model, 
                      system_prompt=Orchestrator_Agent_Prompt)

Command_evaluation_agent = Agent(openai_model, 
                      system_prompt=Command_evaluation_Prompt)

logfire.configure()
logfire.instrument_pydantic_ai(Command_evaluation_agent)
logfire.instrument_pydantic_ai(Orchestrator_agent)

@Command_evaluation_agent.tool
def GeneratedCommand(ctx: RunContext[Union[Agent_output_evaluation,str,ImmigrationProfileModel]]) -> CommandGen:
    logger.debug("Dep: ",ctx.deps)
    logger.debug("[Timestamp] GeneratedCommand started at: %s", datetime.datetime.now())
    logger.debug("\nDebug: Starting GeneratedCommand tool")
    logger.debug("\nDebug: Input context: %s", ctx.deps)
    return

@Orchestrator_agent.tool
def User_AssistantAgent(ctx: RunContext[CommandGen]) -> Union[output_agent,str]:
    logger.debug("[Timestamp] User_AssistantAgent started at: %s", datetime.datetime.now())
    logger.debug("\nDebug: Starting User_AssistantAgent tool")
    agent_command = ctx.deps

    logger.debug("\nDebug: Processing command: %s", agent_command.Command)
    logger.debug("\nDebug: Processing context: %s", agent_command.Context)
    if agent_command.Context == "None":
        result = Assistant_Agent.run_sync(agent_command.Command, model_settings={"timeout": 5}, output_type=output_agent)
    elif agent_command.Context != "None":
        result = Assistant_Agent.run_sync(agent_command.Command, deps=agent_command.Context, model_settings={"timeout": 5}, output_type=output_agent)
    result = output_agent.model_validate(result.output)
    logger.debug("\nDebug: User_AssistantAgent completed with result: %s", result)
    logger.debug("[Timestamp] User_AssistantAgent ended at: %s", datetime.datetime.now())
    return result

@Orchestrator_agent.tool
def SearchingNameAgent(ctx: RunContext[CommandGen]) -> output_agent:
    logger.debug("[Timestamp] SearchingNameAgent started at: %s", datetime.datetime.now())
    logger.debug("\nDebug: Starting SearchingNameAgent tool")
    agent_command = ctx.deps
    logger.debug("\nDebug: Input command: %s", agent_command)
    result = Name_Scraper_Agent.run_sync(agent_command.Command,model_settings={"timeout": 5}, output_type=output_agent)
    result = output_agent.model_validate(result.output)
    logger.debug("\nDebug: SearchingNameAgent completed with result: %s", result)
    logger.debug("[Timestamp] SearchingNameAgent ended at: %s", datetime.datetime.now())
    return result

@Orchestrator_agent.tool_plain
def SearchingDetailAgent(data:output_agent) -> output_agent:
   logger.debug("[Timestamp] SearchingDetailAgent started at: %s", datetime.datetime.now())
   logger.debug("\nDebug: Starting Detail_Scraper_Agent tool")
   logger.debug("\nDebug: context: %s", data)
   result = Detail_Scraper_Agent.run_sync("Divingding the list into smaller lists", deps=data, model_settings={"timeout": 5}, output_type=output_agent)
   result = output_agent.model_validate(result.output)
   logger.debug("\nDebug: SearchingDetailAgent completed with result: %s", result)
   logger.debug("[Timestamp] SearchingDetailAgent ended at: %s", datetime.datetime.now())
   return result


